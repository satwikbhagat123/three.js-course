

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
day-1

Introduction 
00:00
Hello, and welcome. This lesson isn't truly a lesson. It's more of a presentation to introduce myself and present what's coming on your journey.

The main reason for this lengthy introduction, is the fact that this course is quite comprehensive and that you need to be well-prepared.

Not yet a student? 
00:18
Some of the lessons (like this one) are free and the beginning of most lessons is also available for free. I did this so that you can catch a glimpse of the course and what’s in it.

If you’ve already registered to Three.js Journey, ignore this message, because you have access to every lesson. But if you aren’t a Three.js Journey student yet, please have a look. See for yourself and, if you like the content, join us.

Now let me introduce myself.

Who am I? 
00:41
My name is Bruno Simon. I'm a French creative developer, as you can probably hear in the video.

Right now, I'm a freelance developer and work with clients from around the world. I used to be the lead developer for Immersive Garden, a French creative studio. And for many years, I've been a professor for multiple French post-grad and Master's degrees. I teach web development to beginners as well as WebGL with Three.js to more advanced students.

My favorite activity is, as you can guess, WebGL and particularly with Three.js. I've been using it for many years on various projects, and, in 2019, I launched my portfolio (https://bruno-simon.com). I initially meant it to showcase some techniques for my students, but I enjoyed doing it, so I kept improving it, and people seemed to appreciate it.

Here is a selection of client projects I worked on:

https://bruno-simon.com
https://threejs-journey.com
https://www.fromscout.com
https://orano.imm-g-prod.com/experience/innovation/en (original website isn’t live anymore)
https://prior.co.jp/discover/en
https://madbox.io
https://chartogne-taillet.com/en
And some experiments I did just for fun:

https://my-room-in-3d.vercel.app
https://organic-sphere.vercel.app
https://experiment-holographic-terrain.vercel.app
https://experiment-woodkid-volcano-robot.vercel.app
https://infinite-world.vercel.app/
https://awwwards-2022-workshop.vercel.app
Why this course? 
09:15
When I started learning Three.js, I didn't have many resources. The library was flourishing, but it was without a doubt new, and there appeared to be considerable gaps in the documentation. At that time, we had to push through and dig into the code and examples, find threads about frequent problems, and keep trying until it worked.

Nowadays, the documentation is excellent. We have pretty decent tutorials and the library is stable, even though it's still evolving thanks to the community. Yet, an ultimate course that takes you by the hand was still missing. It would help if you had guidance to fully understand this subject and get enough experience to do your projects without struggling or getting lost.

After I launched my portfolio, many people asked me if I could tutor them or where to learn the techniques I use. I had in-depth knowledge of Three.js and I knew how to teach. When I got all those requests, I figured it was time to build that online course for everyone to explore.

What will you learn? 
10:54
Three.js is vast, and you can do an infinite number of things with it. That explains why the course is so long.

The content is separated into chapters and is intended for absolute beginners. If you know nothing about WebGL and Three.js but want to create cool 3D websites, you’ve come to the right place.

Some of you might be tempted to jump straight to specific chapters. Yes, I’m talking to you, you React developer! If you are in a hurry or just eager to learn advanced topics, be my guest and try. Still, my recommendation is to learn the lessons one by one in order. Anyway, if it’s too hard, you can still go back to a previous chapter.

As I’ve mentioned earlier, the course is separated into chapters. Let’s talk a little about each one in order to help you apprehend what’s coming.

In the first chapter, we will learn all the basics, such as creating a first scene, rendering it, adding objects, choosing the right materials, adding textures, animating everything and even put it online. Some might find this part a bit boring since we enumerate a lot of elements. Don’t worry, the fun and creative parts are coming.

In the next chapter, we will go through many classic techniques: for instance, creating our own geometries, adding lights and shadows, interacting with 3D objects, and adding particles. That’s where things get a little more exciting.

In the third chapter, we will learn more advanced techniques and even stray away from WebGL and Three.js, by learning how to create our own 3D models using Blender. That's right! You'll also learn how to use Blender during this course. You’ll also learn how to add physics using the library I used for my portfolio. And I’ll even teach you how I personally organise my code for big projects.

In the fourth chapter, we are going to talk about shaders. If you’ve already heard about shaders, you probably know this is where people start to struggle, and for good reason. Shaders are hard, but shaders will unlock the true power of WebGL. You’ll be able to create things that would seem impossible at first. If you don’t understand what I’m talking about, don’t worry, everything will make sense once you finish this chapter.

In the fifth chapter, we will go the extra mile with even more advanced techniques, such as post-processing, performance optimisation, and how to mix WebGL with HTML.

In the sixth chapter, we will learn how to create a scene like the one you see on the homepage of Three.js Journey. It’s not going to be the same scene because the chapter would have been way longer and boring, but the techniques are exactly the same and you’ll be able to create any kind of scene after that.

And finally, in the seventh chapter, we will learn how to use Three.js in a React application with React Three Fiber. I know many of you are excited about this and I’m sure you’ll love this part. The number of techniques you’ll learn and practice is huge. You’ll even create a game with physics, real game mechanics, UI, and cool effects. Oh and, if you don’t know React, don’t worry, I’ve got you covered. There is a 4-hour long lesson dedicated to learning React basics. That’s a bonus. You came to learn Three.js and you’ll learn a bunch of other things along the way.

Because I'm a creative developer, I'll also do my best to help you create elegant experiences. I'll give you many tips and tricks to find the perfect tweaks for your WebGL creations.

Updates 
17:17
As a web developer, you probably already know how fast things are moving these days. Libraries come and go, updates are happening every day and it’s hard to keep up.

Don’t worry, I’m keeping Three.js Journey up to date. I’ve actually been doing that for a while. As I’m writing this lesson, Three.js Journey has been out for 2 years and during those 2 years, I kept updating the dependencies and the lessons. I’ve added 37 hours of video. Yes, that’s more than half of the current duration of the course. And I’ll keep adding content that students of Three.js Journey, will get access to without paying any extra.

How to study this course? 
18:10
Difficulty
As you go through the lessons, you’ll see that things get harder. You will struggle, but don't worry, it's perfectly normal. No one can understand everything on the first try.

The first thing to understand is that, if it’s hard to learn, it’s valuable knowledge (or a bad teacher), so keep up.

Secondly, yes we approach challenging topics, but then we practice. After tackling challenging topics multiple times, it’ll start to make sense.

Find out how you can learn the best
Each individual has a unique way to learn. It's a valuable lesson for you to find out how you can get the most out of this course.

Find the moment of the day where you learn best. For me, it’s in the morning. Do not try to rush things and complete the whole course in only one week. The brain needs time to process items, and it does it best at night. Maybe try one or two (three tops) lessons a day. Eat well, sleep enough, drink, and stay healthy. And don't forget to shut down any distractions.

Some people like to first focus on the lesson without doing anything else and then try to do the exercise themselves while going back to the lesson with which they struggle.

Some people just like to follow along and wait for the end of the lesson to then venture on their own by going the extra mile on the topic.

Of course, you don't need to finish the whole course to start working on projects, whether personal or professional. If you feel like dropping out and want to start creating on your own, go ahead! The course will be there waiting for you if you need it.

The videos
If you are watching the video right now, you’ll notice that the player has some handy features.

As an example, you can change the speed of the video if you feel like it’s going too fast or too slow.

You also have access to a bunch of shortcuts. You can see the various sections. You can go fullscreen. The video stays visible when you scroll down. Etc.

Use those features as you please.

Lessons
You might have noticed that lessons are available both as video and text. Text versions are almost the same and you get access to screenshots, video previews, code with syntax highlights, etc. Use the version you prefer.

During each lesson, we will go through various documentation pages, online tools, and examples. All the links will be available under the "🔗 Lesson's links" button at the bottom-right of each page. Go ahead and click on those when you want to dive deeper into any of the topics we cover.

Exercises
Learning is a matter of practicing which is why a starter file is provided with almost every lessons.

The final version of the exercise is also provided in case you want to check the result directly.

More about what’s in those zip files and how to use them soon.

Code
Each developer has a personal way of coding and I have mine. During the lesson, the code will follow my personal preferences. Do as you wish. If you want to refactor all the code, go ahead. You can even use a code beautifier that will automatically reformat your code.

Prerequisite 
23:38
You need a computer on which you can install software and code. Some course portions might vary depending on the OS, like the Terminal commands or some Blender shortcuts. I'll always provide the MacOS and Windows versions.

This course is beginner-friendly, yet you do need to know JavaScript basics like variables, array, objects, loops, functions, and events.

You will also need a code editor. I recommend Visual Studio Code because it's a well-oiled editor with a broad community and extended updates coming every month. However, you can use the editor that suits you. There will be a few instances when we install plugins, but again, it won't be a big deal, and you'll probably find corresponding plugins for your code editor.

Another requirement is a modern browser with useful developer tools. I'll be using Chrome, but you can also use Firefox. Please don’t use Safari or Edge. They do the trick when it comes to navigating, but not when it comes to debugging. At some point, we will install Chrome extensions, but those extensions are optional. Also, be careful with browsers that implement special security and privacy features like Brave. They might interfere with your code.

We will also learn how to use Blender. It's a piece of free 3D software that works on every primary OS, and it's just great. If you are curious, give it a try already.

You don't need to be good at maths. I'm terrible at it, and still, I manage to create cool WebGL experiences. Yes, being good at it would be a plus, but you can do without it, and I'll explain the formulas.

Finally, if you know nothing about Three.js, you're in the right place.

What to do if I'm stuck? 
26:55
If you get stuck for whatever reason, don't worry, you're not alone.

Join the Discord
As a Three.js Journey student, you get access to a members-only Discord Server. Simply click on the Discord button at the top right corner of this page and join the Private server.

There are currently thousands of members there including myself, and we will do our best to help you. In return, if you feel like helping others, that would be awesome and I would appreciate it a lot.

By the way, the link to join the Private Discord will work only once, so make sure you join with the right account (I know some of you have a bunch of Discord accounts for some reason).

If you need to join the server later, you don’t need to go through the Three.js Journey website again. The link won’t work. Just open your Discord application and the Three.js Journey Discord server will be there on the left:



Post your issue
As for posting your issue, there is one channel per lesson. Please use the appropriate one, and if your question is not related to a lesson (like if it’s for a personal project), use the #general-questions channel.

Be brief and concise.

If you have screenshots or videos, that’s even better, but most of the time, you’ll need to share some code. In Discord, you can use triple-back quotes (it’s like a quote but a tilted back) to send the code.

Here’s an example:

```js
const hello = 'there'
```
Adding the language (js in this case) will add syntax highlight. This will greatly help us on helping you out.

Post your work 
31:12
You are here to learn how to create 3D websites, right?

You don’t have to finish the whole course to create nice projects. After a few lessons, you’ll see that you’ll have sufficient knowledge to venture out on your own and have some fun.

But what is it worth if you can’t share it with the world? Well, good news, in the Go Live lesson, you’ll learn how to put your projects online for free.

As for getting some attention, personally, I like using Twitter. That’s why I’ve created a #threejsJourney hashtag. Use it or tag me (@bruno_simon) so that I can see what you do. If I like it, I’ll retweet it and give you some extra visibility.

You can also post on the Discord server which is ideal if you want some feedback. Go on the Three.js Journey Discord server and post on the #students-work channel.

Certificate 
33:24
Finally, there is a certificate of completion for this course.

But don’t think I’ll just offer it to you just for watching all the videos. You’ll have to answer a quiz for each lesson. You can access the quiz from the lesson page (button right below the player) or from the pop-in that opens at the end of the lesson.

All quizzes are also accessible from your account page.

You need to have registered to Three.js Journey in order to see the quizzes.

If you answer incorrectly, you’ll have to wait a few minutes before trying again. Enough time for you to go gather the information in order to answer successfully.

The final certificate looks something like this https://threejs-journey.com/certificate/view/17

You can share it and even print it.

Conclusion 
35:15
It was quite a long introduction, but I wanted to make sure you start on a good foot.

Now is the time to learn Three.js.

Next lesson


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    
day-2



Introduction 
00:00
If you are here, you probably already know what Three.js is but let's talk about it and see why we need this library.

Three.js is a 3D JavaScript library that enables developers to create 3D experiences for the web. It works with WebGL, but you can make it work with SVG and CSS as well. Those two are quite limited, and we won't cover them in this course.

Showcase 
01:06
Here's a preview of what you can achieve with Three.js:

https://bruno-simon.com
https://cornrevolution.resn.global/
https://richardmattka.com
https://lusion.co
https://www.oculus.com/medal-of-honor/
http://letsplay.ouigo.com
https://zen.ly
https://prior.co.jp/discover
https://www.midwam.com
https://heraclosgame.com
https://chartogne-taillet.com
https://live.vanmoof.com/site
Before going further, we need to know what WebGL is exactly.

What is WebGL? 
10:21
WebGL is a JavaScript API that renders triangles in a canvas at a remarkable speed. It's compatible with most modern browsers, and it's fast because it uses the Graphic Processing Unit (GPU) of the visitor.

WebGL can draw more than triangles and can also be used to create 2D experiences, but we will focus on 3D experiences using triangles for the course's sake.

The GPU can do thousands of parallel calculations. Imagine that you want to render a 3D model and this model is constituted of 1000 triangles—which, come to think about it, is not that many. Each triangle includes 3 points. When we want to render our model, the GPU will have to calculate the position of these 3000 points. Because the GPU can do parallel calculations, it will handle all the triangles points in one raw.

Once the model's points are well placed, the GPU needs to draw each visible pixel of those triangles. Yet again, the GPU will handle the thousands and thousands of pixels calculations in one go.

The instructions to place the points and draw the pixels are written in what we call shaders. And let me tell you, shaders are hard to master. We also need to provide data to these shaders. For example: how to place the points according to the model transformations and the camera's properties. These are called matrices. We also need to provide data to help colorize the pixels. If there is a light and the triangle is facing that light, it should be brighter than if the triangle isn't.

And this is why native WebGL is so hard. Drawing a single triangle on the canvas would take at least 100 lines of code. Good luck if you want to add perspective, lights, models, and animate everything in that case.

But native WebGL benefits from existing at a low level, very close to the GPU. This enables excellent optimizations and more control.

Three.js to the rescue 
18:52
Three.js is a JavaScript library under MIT license that works right above WebGL. The library's goal is to drastically simplify the process of handling all of what we just stated. You'll have an animated 3D scene in just a few code lines, and you won't have to provide shaders and matrices.

Because Three.js is right above WebGL, we can still interact with it in some ways. At some point, we will get to writing shaders and create matrices.

Ricardo Cabello, aka Mr.doob (Website, Twitter), is the developer who created Three.js. He is still working on it, but now he's helped by a large community. You can check the list of contributors here: https://github.com/mrdoob/three.js/graphs/contributors

Currently, the library gets an update every month and you can see what's changed in the releases page here: https://github.com/mrdoob/three.js/releases

You can discover many exceptional projects using Three.js on the website's homepage: https://threejs.org/

There is also some well-maintained documentation that we will use a lot: https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene

And you can find hundreds of examples with public code here: https://threejs.org/examples/#webgl_tonemapping

If you want to follow updates and discover exceptional projects, I advise you to follow the Mr.doob and Three.js twitter accounts:

https://twitter.com/mrdoob

https://twitter.com/threejs

What about other libraries? 
23:01
Three.js is the most popular WebGL library for good reasons that we already covered. It's very stable, it provides many features, the documentation is remarkable, the community is working hard on updates, and it's still close enough to native WebGL.

That's why it's probably better to learn Three.js.

But there are many other libraries, and some of them are amazing as well. Be curious, try them out, and experience their strength for yourself. You might even learn things that will be useful for your Three.js projects.



---------------------------------------------------------------------------------------------------------------------
my own notes 

what is webgl?

webgl is a javascript api for rendering 3d graphics in the browser.
results can be drawn in a <canvas>
compatible with most modern browsers
uses the GPU (graphics processing unit) thats why its fast 
can be used to create 3d and 2d models, animations, and games
the CPU can do calculations really fast but one by one . the GPU is a little slower but can do thousands of parallel calculations 
to draw a 3d model,the idea is to draw many traingles at the right position and colorize them so that they look the way we want
the GPU will position all those points at once according to many factors
once the points are placed , the GPU will draw each visible pixels of those traingles 
again , those thousands of pixels will be calculated and drawn in parallel extremely fast
the instructions to place the points and draw the pixels are written in what we call shaders.
we provide a bunch of information to those shaders like the points positions models transformations, the camera coordinates and things get positions and colorized the way we want 
this is why native webgl is hard to master 
drawing a single triangle on the canvas would take at least 100 lines of code 
native webgl benifits from existing at a low level which enables excellent optimizations and more control 

three.js to the rescue 

three.js is a javascript library under MIT license that works right above webgl. the goal of the library is to drastically simplify the process of handling all of what we just stated. you'll have an animated 3d scene in just a few code lines, and you won't have to provide shaders and matrices.

three.js drastically simplifies the process of all of this 
we still can interact with webgl and we can create our own shaders and provide our own information 
three js is a most popular webgl library , it's very stable, it provides many features, the documentation is remarkable, the community is working hard on updates, and it's still close enough to native webgl 
but there are many other libraries and some of them are amazing as well 
be curious, try them out, and experience their strength for yourself 
you might even learn things that will be useful for your three.js projects



---------------------------------------------------------------------------------------------------------------------


NOTES IN HINGLISH 
WebGL kya hai?
WebGL ek JavaScript API hai jo browser mein 3D graphics render karne ke liye use hoti hai.
Results ko <canvas> mein draw kiya ja sakta hai
Modern browsers ke saath compatible hai
GPU (graphics processing unit) ka use karti hai isliye ye fast hai
3D aur 2D models, animations, aur games banane ke liye use ki ja sakti hai
CPU calculations bahut tezi se kar sakta hai lekin ek ek karke. GPU thoda slow hai lekin hazaron parallel calculations kar sakta hai
3D model draw karne ke liye, idea ye hai ki bahut saare triangles ko sahi position pe draw karo aur unhe colorize karo taaki wo humari marzi ke hisaab se dikhe
GPU saare points ko ek saath position karega different factors ke according
Jab points place ho jaate hain, GPU un triangles ke har visible pixel ko draw karega
Phir se, hazaron pixels ko parallel mein calculate aur draw kiya jaayega extremely fast
Points ko place karne aur pixels draw karne ke instructions ko shaders kehte hain
Hum in shaders ko bahut saari information provide karte hain jaise points positions, model transformations, camera coordinates aur cheezein position aur colorize ho jaati hain jaise hum chahte hain
Isliye native WebGL ko master karna mushkil hai
Canvas pe ek simple triangle draw karne ke liye kam se kam 100 lines of code chahiye
Native WebGL low level pe exist karne ka fayda uthati hai jo excellent optimizations aur zyada control provide karti hai
Three.js ka sahara
Three.js ek JavaScript library hai jo MIT license ke under WebGL ke upar work karti hai. Library ka goal hai ki upar bataye gaye saare processes ko bahut simple bana de. Aap sirf kuch lines of code mein animated 3D scene bana sakte ho, aur aapko shaders aur matrices provide karne ki zarurat nahi padegi.
Three.js in sabhi processes ko bahut simple bana deti hai
Hum abhi bhi WebGL ke saath interact kar sakte hain aur apne khud ke shaders bana sakte hain aur information provide kar sakte hain
Three.js sabse popular WebGL library hai, ye bahut stable hai, bahut saare features provide karti hai, documentation zabardast hai, community updates pe hard work kar rahi hai, aur ye native WebGL ke kaafi close hai
Lekin bahut saari doosri libraries bhi hain aur unme se kuch amazing bhi hain
Curious bano, unhe try karo, aur khud unki strength ko experience karo
Ho sakta hai aap kuch aisa seekh lo jo aapke Three.js projects ke liye useful ho



---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
day-03


Introduction 
00:00
Enough talking, now is the time to start coding and creating our first Three.js scene.

If you are familiar with nowadays front-end development tools like Node.js and Vite, you can probably skip most of this lesson.

Otherwise, stick with us and do not worry, as I’m going to explain everything in detail.

Local server and build tools 
00:33
In order to run our soon-to-be Three.js website, we need to run a local server.

We could have created an HTML file somewhere on our computer and double-click on it, but browsers limit the functionalities of websites opened like this for security reasons. As a result, we won’t be able to load Three.js, models, textures, etc.

The simplest solution to this problem is to use a “build tool” or “bundler”.

The state of build tools
There are many build tools available these days and you’ve probably heard of some of them like Webpack, Vite, Gulp, Parcel, etc.

They all have various features with pros and cons, but we are going to use a very specific one in the following lessons.

Nowadays, the most popular build tool is Webpack. It’s widely used, it has a great community and you can do a lot with it. But while Webpack is the most popular, it’s not the most appreciated.

In fact, the most appreciated build tool these days is Vite (French word for "quick", pronounced /vit/, like "veet”). It’s faster to install, faster to run, and less prone to bugs. Ultimately, the developer experience is much better.

Initially, all Three.js Journey exercises were running on Webpack and some of the following lessons have been recorded like that. But now, exercises are running on Vite. Don’t worry, I’ve configured Vite so that the files and Vite’s behaviour look very similar to the Webpack configuration and you might not even notice the difference while following the videos.

Vite
This is not a lesson about Vite, but because I can’t help myself, I’m going to explain a few things about it.

As mentioned earlier, Vite is a build tool. The idea is that we are going to write web code like HTML/CSS/JS and Vite will build the final website. It’ll also do a bunch of things like optimizations, cache breaking, source mapping, running a local server, etc.

While Vite handles the most basic needs, we can also add plugins in order to handle more features like exotic languages, or special files. We are actually going to add plugins later in the course, which will be able to handle GLSL files in order to create custom shaders but also to run React.

Vite was created by Evan You, the creator of Vue.js, is highly maintained by hundreds of developers, and is getting a lot of hype.

First Vite project
You might have noticed a starter file associated with this lesson. In later lessons, you’ll also find a final file.

The starter file is the one you’ll need to start in order to follow the exercise and the final file is the final result of the exercise in case you need it. But instead of using the starter file right away, I’m going to show you how to start a project from scratch. At a later stage, we are going to use that file.

Terminal
We are going to run some commands in the terminal. We could use the Terminal (MacOS) or Command Prompt (Windows), but I actually recommend you to run the terminal integrated into VSCode (if you are using VSCode like me). Launch VSCode and press CMD + J (MacOS) or CTRL + J (Windows) to open the integrated terminal.

If you do so, the following commands will be the same regardless of your OS.

The terminal works a bit like your file explorer and you need to be in the right folder to run the commands.

You can use cd followed by the name of the folder to browse in it. You can also use cd (with a space at the end), and drag and drop the folder. You can test where you are with pwd and list the files in the current folder with ls.

Troubleshooting
We are going to do a bunch of commands and manipulations. If you are having any kind of issue, there is a section near the end of the lesson where I enumerate classic issues. If you still can’t make it work, as a member of Three.js Journey, you get access to a private Discord server. Use the top menu to access the Discord page and share your issue there. We will help you out.

Node.js
In order to run Vite, you need to have Node.js installed on your computer.

Node.js enables running JavaScript on your computer outside of a browser. It’s great to run various tools like Vite, it has been around for many years and is very popular.

If you don’t know if Node.js is already installed or which version is installed run node -v from your terminal.

If the answer tells you that the node command isn’t recognised, then it’s not installed.

If it’s installed, the answer will contain the current version. Make sure it’s updated to the last version. Vite currently works with version 14.18 and above, but I recommend you always have the LTS (Long Term Support) version of Node.js installed.

To install or update Node.js, go to https://nodejs.org/en/, download the “LTS” and install it with the default settings.

Close your Terminal (MacOS) or Command Prompt (Windows), re-open it, and run node -v again to check the version.

Create a Node.js project
Now that we have Node.js and we know how to use the terminal, it’s time to create our Node.js project.

Create a folder that will contain your website (try to stay organised, there are a bunch of lessons to come).

What you can do now is open that folder in VSCode (if you are using VSCode). This will come in handy for two main reasons:

The VSCode terminal will already be located in that folder.
We can manage the files more easily from the sidebar and those files won’t be hidden unlike with your OS file explorer.
Now open the terminal that should be located in that folder and run npm init -y.

When we installed Node.js, we automatically installed NPM. NPM stands for Node Package Manager and is a dependency manager that will fetch the packages we need such as Three.js, Vite, and the various libraries we are going to use in the course. Additionally, NPM comes with a command line interface named npm that we can use from our terminal.

By running npm init -y, NPM will create a package.json that will contain the minimal information needed to run a Node.js project.

Add dependencies
In this lesson, we are going to use two dependencies. Vite and Three.js.

If you are curious, you can find them on the NPM website:

Vite (as vite)
Three.js (as three)
For now, we are going to focus on Vite only and add Three.js later. To add a dependency to a Node.js project, in the terminal, run npm install vite.



You should notice three things.

A node_modules/ folder has been created. This folder contains the project dependencies and you should never modify things inside that folder. Besides containing the vite dependency as the vite/ folder, it also features the other dependencies that are being used by vite.
The package.json has been updated and now contains an array of dependencies written in the "dependencies" properties with numbers corresponding to the version with a level of tolerance.
A package-lock.json has been written and contains information about the dependencies and the exact versions that have been installed in your project without tolerance.
Those 2 files and the folder enable project sharing. If you want to share your beautiful Three.js website with another developer, you’ll want to remove the node_modules folder and share the rest of the project. The other developer will retrieve your project and run a command that will automatically re-create the node_modules folder according to what is written in package.json

Don’t know how to do that? Don’t worry, we are going to review that command shortly. Note that package-lock.json is optional, but if it’s present in the project, the other developer will get the exact same versions of the dependencies as you with no tolerance.

Basic website
We have our Node.js project, we have Vite added as a dependency. Now, we need to create a basic website.

Still in the project folder, create an index.html file:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>03 - First Three.js Project</title>
</head>
<body>
    <h1>Soon to be a Three.js website</h1>
</body>
</html>
Do not open this file directly! Doing so would go against what we are doing right now with Vite.

In package.json, replace the "scripts" part with the following:

{
  // ...
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  },
  // ...
}
By having those two “scripts”, we can now run those dev and build commands from the terminal and those commands will trigger vite and vite build respectively by using the vite/ dependency from the node_modules/ folder.

To run the dev script, in the terminal, run npm run dev.



Vite should display a URL looking something like http://localhost:5173/. Copy it and paste it into your browser to open it like any website.



Congratulations, you have your Vite website running.

Your terminal might seem stuck, but it’s actually running the server right now, and stopping the script will result in shutting down the server, which we will do shortly.

The build command will output the final version of the website. However, this is for a later lesson, where we will learn how to put our website live.

Add JavaScript
This is great, but now we want to execute some JavaScript on our beautiful website.

Still in the project folder, create a script.js file:

console.log('JavaScript is working')
In the index.html, add the following <script> at the end, inside of the <body>:

<!-- ... -->
<body>
    <h1>Soon to be a Three.js website</h1>
    <script type="module" src="./script.js"></script>
</body>
</html>
Don’t forget the type="module".

Open your Developer Tools (or DevTools) and you should see JavaScript is working in the Console.



You might have noticed that you didn’t even have to reload the page. Vite detects the change and reloads the page for you.

Three.js 
37:12
Just like we added Vite to the project, we need to add Three.js.

Add the dependency
The name of the dependency on NPM is three.

We need to run npm install three but our terminal is currently busy running the Vite server.

You have two options:

Open a new terminal and run the command while making sure you are in the same folder.
Shut down the server, run the command, and start the server again.
We are going to shut down the server.

Press CTRL + C to stop the server. You might need to press the shortcut multiple times on a Windows OS or confirm with the letter o.

Now run npm install three:



The three/ folder should have been added to the node_modules/ folder and both package.json and package-lock.json now contain references to it.

Restart the server with npm run dev:



Import Three.js
Back to script.js, we can import Three.js from the three dependency by writing:

import * as THREE from 'three'
This will import all core classes of Three.js inside the THREE variable from the three dependency.

This way of importing dependencies is called “ES modules”. We won’t dive too much into that topic, since it’s related to JavaScript basics more than Three.js. In the future, we will cover additional examples throughout the course, when we need them.

Use Three.js
Inside of our script.js file, we now have access to a variable named THREE. Be careful and always write it using uppercase.

If you console.log() this variable, you'll see that there is a lot going on inside:

import * as THREE from 'three'

console.log(THREE)


The THREE variable contains most of the classes and properties you might need on a classic Three.js project. Unfortunately, not all classes are inside this variable, but we will see later how to access them.

To use one of those classes, you need to instantiate it. For example, if you want to create a scene, you'll write const scene = new THREE.Scene(). If you want to create a sphere geometry, you need to write const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32) —We'll dig deeper into these later.

First scene
It's time to create our scene and produce something on the screen.

We need 4 elements to get started:

A scene that will contain objects
Some objects
A camera
A renderer
Scene
The scene is like a container. You place your objects, models, particles, lights, etc. in it, and at some point, you ask Three.js to render that scene.

To create a scene, use the Scene class:

// Scene
const scene = new THREE.Scene()
Objects
Objects can be many things. You can have primitive geometries, imported models, particles, lights, and so on.

We will start with a simple red cube.

To create that red cube, we need to create a type of object named Mesh. A Mesh is the combination of a geometry (the shape) and a material (how it looks).

There are many geometries and many materials, but we will keep things simple for now and create a BoxGeometry and a MeshBasicMaterial.

To create the geometry, we use the BoxGeometry class with the first 3 parameters that correspond to the box's size.

// Object
const geometry = new THREE.BoxGeometry(1, 1, 1)
To create the material, we use the MeshBasicMaterial class with one parameter: an object {} containing all the options. All we need is to specify its color property.

There are many ways to specify a color in Three.js. You can send it as a JS hexadecimal 0xff0000, you can send it as a string hexadecimal '#ff0000', you can use color names like 'red', or you can send an instance of the Color class —we'll cover more about it later.

// Object
const geometry = new THREE.BoxGeometry(1, 1, 1)
const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
To create the final mesh, we use the Mesh class and send the geometry and the material as parameters.

// Object
const geometry = new THREE.BoxGeometry(1, 1, 1)
const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
const mesh = new THREE.Mesh(geometry, material)
You can now add your mesh to the scene by using the add(...) method:

scene.add(mesh)
If you don't add an object to the scene, you won't be able to see it.

Camera
The camera is not visible. It's more like a theoretical point of view. When we will do a render of your scene, it will be from that camera's point of view.

You can have multiple cameras just like on a movie set, and you can switch between those cameras as you please. Usually, we only use one camera.

There are different types of cameras, and we will talk about these in a future lesson. For now, we simply need a camera that handles perspective (making close objects look more prominent than far objects).

To create the camera, we use the PerspectiveCamera class.

There are two essential parameters we need to provide.

The field of view

The field of view is how large your vision angle is. If you use a very large angle, you'll be able to see in every direction at once but with much distortion, because the result will be drawn on a small rectangle. If you use a small angle, things will look zoomed in. The field of view (or fov) is expressed in degrees and corresponds to the vertical vision angle. For this exercise we will use a 75 degrees angle.

Here's a video to explain what the field of view variation looks like:

The aspect ratio

In most cases, the aspect ratio is the width of the canvas divided by its height. We haven't specified any width or height for now, but we will need to later. In the meantime, we will create an object with temporary values that we can re-use.

Don't forget to add your camera to the scene. Everything should work without adding the camera to the scene, but it might result in bugs later:

// Sizes
const sizes = {
    width: 800,
    height: 600
}

// Camera
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)
scene.add(camera)
Renderer
The renderer's job is to do the render. Bet you didn't see that coming!

We will simply ask the renderer to render our scene from the camera's point of view, and the result will be drawn into a canvas. You can create the canvas by yourself, or let the renderer generate it and then add it to your page. For this exercise, we will add the canvas to the HTML and send it to the renderer.

In index.html, instead of the <h1>, create the <canvas> element before you load the scripts and give it a class:

<canvas class="webgl"></canvas>
To create the renderer, we use the WebGLRenderer class with one parameter: an object {} containing all the options. We need to specify the canvas property corresponding to the <canvas> we added to the page.

Create a canvas variable at the start of the code, then fetch and store in it the element we created in the HTML using document.querySelector(...).

It's better to assign the canvas to a variable because we'll use it for other purposes in the next lessons.

We also need to update the size of your renderer with the setSize(...) method using the sizes object we created earlier.

The setSize(...) method will automatically resize our <canvas> accordingly:

// Canvas
const canvas = document.querySelector('canvas.webgl')

// ...

// Renderer
const renderer = new THREE.WebGLRenderer({
    canvas: canvas
})
renderer.setSize(sizes.width, sizes.height)
Right now, you won’t be able to see anything, but your canvas is there and has been resized accordingly. You can use the Developer Tools to inspect the <canvas> if you are curious.

First render
It's time to work on our first render. Call the render(...) method on the renderer and send it the scene and the camera as parameters:

renderer.render(scene, camera)


A black screen? Where is our object?

Here's the issue: we haven't specified our object's position, nor our camera's. Both are in the default position, which is the center of the scene and we can't see an object from its inside (by default).

We need to move things.

To do that, we have access to multiple properties on each object, such as position, rotation, and scale. For now, use the position property to move the camera backward.

The position property is an object with three relevant properties: x, y and z. By default, Three.js considers the forward/backward axis to be z.

To move the camera backward, we need to provide a positive value to that property. You can do that anywhere once you've created the camera variable, yet it has to happen before you do the render:

const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)
camera.position.z = 3
scene.add(camera)


Congratulations, you should see your first render. It looks like a square, and that's because the camera aligns perfectly with the cube, and you can see only one side of it.

Don't worry about the render's size; we'll learn how to make the canvas fit the viewport later.

In the next lessons, you will learn more about the position, rotation, and scale properties, how to change them, and animate the scene.

Using the starter 
01:04:55
While we’ve learned how to do it from scratch, a starter file is provided with every exercise so that you don’t have to go through the whole process every time.

Moreover, you can actually find a starter with this lesson.

Most following lessons will work just the same and I’m going to explain how to use those files in order to complete the exercises as you follow the lessons.

Zip files
Download and unzip the starter file (right below the player).

Unzipping a file depends on your OS and which applications you have installed. On MacOS, you can double-click on it. On Windows, you should right-click and choose something like Extract…, followed by options like the folder in which it’ll be unzipped.

Dependencies
You might have noticed that the node_modules/ folder isn’t there. As mentioned earlier, when sharing a Node.js project, do not share the node_modules/ because this folder can get tremendously big.

Yet, we need the dependencies and those are actually listed in the package.json file. To install those listed dependencies, open the terminal in the project folder and run npm install:



Wait for a little while dependencies are being fetched and you should see a node_modules folder being created alongside the package-lock.json.

Run the server
Now, to run the server, from the terminal in the project folder, run npm run dev.

Wait a second or two and the website should open in your default browser.

If the page doesn’t open, the terminal should display two URLs that look something like http://localhost:5173/ and http://192.168.1.25:5173/.

Try them in your browser:



The configuration is slightly more advanced than what we’ve done earlier from scratch.

There is a vite.config.js in which I provide some specific settings. We won’t go into details because we’ve spent already too much time talking about Vite. Yet, if you are curious, you can find all the information you need on the Vite documentation.

Troubleshooting 
01:09:40
If everything’s worked out, you can skip this section.

If you’ve had issues along the way, I’m going to enumerate some classic troubleshooting and how to fix those issues.

Terminal folder
Make sure your terminal is opened in the project folder.

Use the pwd command to display the folder in which the terminal is currently.

Use the cd (with a space at the end) command, drag and drop the folder, and then press Enter to move the terminal into that folder.

Long path
If your project folder is nested very deep in other folders, you might end up with a path so long that Node.js can’t handle it.

Move the folder up and make sure to move the Terminal accordingly before trying again.

Versioned folder
Be careful with tools like OneDrive, Google Drive, Dropbox, etc. that will “save” your files online.

They can mess up your Node.js dependencies.

Try to move the project outside of those “saved” folders.

Special characters in the path
Avoid having special characters in the path from the root of your computer down to the project.

Ideally, you should only have lowercase letters, numbers, dashes, and underscores.

MacOS and Xcode
MacOS might ask you to install “Xcode Command Line Tools”.

It’s usually a harmless warning, but sometimes it prevents the Node.js project from running.

If you want more info, follow this article. But to sum it up, just run xcode-select --install from your terminal and follow the instructions.

Permissions
Sometimes, permissions are messed up and NPM can’t install the dependencies.

If you know what you are doing, try to fix the permissions. Otherwise, delete the folder, re-download the starter, and follow the instructions again.

Vulnerabilities
While you install dependencies, NPM might warn you about “vulnerabilities”. Those are most of the time (if not always) harmless. I’m keeping the course dependencies up to date regularly in order to avoid those warnings but you should not worry too much.

Do not try to fix them using the command suggested by NPM, otherwise, you might end up with different versions than the ones we use in the lesson, resulting in bugs.

Still not working
If you can't find the problem, go to the course's Discord server and share any information you have. We will help you out.

More about the Vite configuration 
01:15:06
Here are a few things you need to know about the Vite configuration and some reminders:

You need to run npm install only once after downloading the project.
You need to run npm run dev each time you want to run the server and start coding. Your terminal might seem stuck, but it's perfectly normal, and it means that the server is running.
The only folders you need to explore, are the src/ and the static/ folders.
In the src/ folder, you can find the traditional index.html, script.js, and style.css files.
You can put static files (also called “public files”) in the static/ folder. Those files will be served as if they were available in the root folder (without having to write static/). You can test by adding /door.jpg at the end of the URL (http://localhost:5173/door.jpg). We'll use this to load textures and models later.
The page will automatically reload as you save any of those files.
You can access your local server from any other device on the same network by typing the same URL that looks something like this http://192.168.1.25:5173. It’s very useful to debug on other devices like mobiles. If it’s not working, it’s usually because of your firewall.
Conclusion 
01:18:45
And that’s it. We are ready to go through the many lessons and use the various exercises.

If you are not confident about doing that again on your own, don’t worry, we are going to do it together in the next lesson.

Remember that some of the following lessons have been recorded using Webpack and you might see slight differences. You should be able to ignore those differences.

How about we do some Three.js now?


NOTES IN HINGLISH



Three.js Setup aur Basic Scene Creation (Hinglish mein)
Local Server aur Build Tools
Three.js website chalane ke liye humein ek local server ki zarurat hoti hai. Hum direct HTML file ko double-click karke nahi chala sakte kyunki browser security reasons ki wajah se kuch functionalities ko limit kar deta hai.
Build Tools ke baare mein
Aajkal bahut saare build tools available hain jaise:
Webpack
Vite
Gulp
Parcel
Hum Vite use karenge kyunki ye:
Install karne mein fast hai
Run karne mein fast hai
Bugs kam aate hain
Developer experience better hai
Basic Setup Steps
Node.js Install Karna


# Check if Node.js installed hai
node -v

# Agar installed nahi hai toh nodejs.org se download karo


Project Setup


# New folder banao
# Terminal mein folder mein jao
npm init -y
npm install vite
npm install three


Basic Files Create Karna


<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Three.js Project</title>
</head>
<body>
    <canvas class="webgl"></canvas>
    <script type="module" src="./script.js"></script>
</body>
</html>


Three.js Scene Setup


// script.js
import * as THREE from 'three'

// Scene banao
const scene = new THREE.Scene()

// Red cube banao
const geometry = new THREE.BoxGeometry(1, 1, 1)
const material = new THREE.MeshBasicMaterial({ color: 0xff0000 })
const mesh = new THREE.Mesh(geometry, material)
scene.add(mesh)

// Camera setup
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight)
camera.position.z = 3
scene.add(camera)

// Renderer setup
const renderer = new THREE.WebGLRenderer({
    canvas: document.querySelector('canvas.webgl')
})
renderer.setSize(window.innerWidth, window.innerHeight)
renderer.render(scene, camera)



Important Points (Yaad Rakhne Wali Baatein)
1. npm install sirf ek baar run karna hai project download karne ke baad
Development server start karne ke liye:

npm run dev


Project mein 2 important folders hote hain:
src/ - Main code files (HTML, JS, CSS)
static/ - Images, textures, models wagera
Agar koi problem aaye toh:
Terminal right folder mein hai ki nahi check karo
Path mein special characters nahi hone chahiye
Node modules folder delete karke phir se install karo
Discord pe help maang sakte ho
Remember: Shuruat mein thoda complicated lag sakta hai, lekin practice ke saath easy ho jayega!



my own notes

make THREE.js work the simplest possible way
no bundler, no modules , no dependencies
a javascript and a HTML file

f12 open developer tools

how to load three.js
go to three.js website
click on download
that file is quite heavy but we need one file from it
go to build folder
copy and paste the three.min.js file to your project
add the script at the end of the body tag in the HTML file
add it before the script.js file because we the libraries need to be loaded first

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>
use this cdn link because the file update ho gya h aur isme nhi h maine chat gpt se search maar ke kiya h 

like this is the full code of html

<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>03-basic-scene</title>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@latest/build/three.min.js"></script>
    <script src="./script.js"></script>
    
</body>
</html> -->


how to use three.js

the three varible contains most of the classes and properties but not all of them 
log it in the console with console.log(THREE)
always use uppercase for THREE

script.js file
<!-- console.log(THREE); // Should print "object" if Three.js is loaded -->


FIRST SCENE

4 elements are needed to create a scene
1. scene that will contain objects
2. camera
3. renderer that will render the scene
4. mesh that is a geometric object in the scene

SCENE
like a container
we put objects , models , lights etc in it
at some point we ask three.js to render the scene

<!-- const scene = new THREE.Scene() -->

OBJECTS
can be many things
primitive geometries
imported geometries
particles
lights
etc
start with a simple red cube

to create a visible object we call that a MESH
combination of geometries(shape) and materials(how it looks)
start with a BoxGeometry and a MeshBasicMaterial

GEOMETRY
inatantiate a BoxGeometry

<!-- const geometry = new THREE.BoxGeometry(1, 1, 1) -->
the first three parameters are the width, height and depth which are all 1 in this case

MATERIAL
C MeshBasicMaterial

<!-- const material = new THREE.MeshBasicMaterial({ color: "red" }) -->

multiple ways to express color
"red"
0xff0000
#ff0000
color

MESH
inatantiate a MESH with the geometry and material

<!-- const mesh = new THREE.Mesh(geometry, material) -->

add it to the scene with the add(...) method

<!-- scene.add(mesh) -->

CAMERA

not visible 
serves as a point of view when doing a 3d render
can have multiple and switch between them
different types
we are going to use PerspectiveCamera

const camera = new THREE.PerspectiveCamera(...)
scene.add(camera)


two essential parameters

1. the field view 
vertical vision angle 
in degree
also called fov
for this exercise we use 75 degree angle

const camera = new THREE.PerspectiveCamera(75,,...)
scene.add(camera)

2. aspect ratio
the width of the renderer divided by the height of the renderer
we dont have to render yet, but we can decide on a size now
create a sizes object containing temporary values

const sizes = {
    width: 800,
    height: 600
}

//camera
const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)
scene.add(camera)

<!-- const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight)  //75 is the field of view and window.innerWidth / window.innerHeight is the aspect ratio
scene.add(camera) -->

23.15



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
day-3

local server and build tools:-
we could have created an HTML